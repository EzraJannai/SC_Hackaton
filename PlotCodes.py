# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ixxSaPScOCPP8LwH7kJFdFEIgQDalQ0K
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from scipy.integrate import solve_ivp

# --- Parameters ---
g = 9.81
D = 10.0
nx = 250
x_start, x_end = 0.0, 5.0
x = np.linspace(x_start, x_end, nx)
dx = x[1] - x[0]
t_start, t_stop = 0.0, 1.0
cf = 0  # friction coefficient

# --- Bed profile (wavy) ---
zb = -D + 0.4 * np.sin(2 * np.pi * x / x_end * ((nx - 1)/nx) * 5)

# --- Initial condition ---
def initial_conditions():
    h0 = 1 * np.exp(-100 * ((x / x_end - 0.5) * x_end)**2) - zb
    q0 = np.zeros_like(h0)
    return np.concatenate([h0, q0])

# --- GABC treatment at domain ends ---
def apply_gabc(h, q, dhdt, dqdt):
    # Left boundary x=0
    c = np.sqrt(g * max(h[0], 1e-6))
    dqdt_in = (1 / h[0]) * (dqdt[0] - (q[0]/h[0]) * dhdt[0] + c * dhdt[0])
    dqdt_out = (1 / h[0]) * (dqdt[0] - (q[0]/h[0]) * dhdt[0] - c * dhdt[0])
    dqdt[0] = dqdt_in + dqdt_out  # superpose characteristics (simplified)

    # Right boundary x=L
    c = np.sqrt(g * max(h[-1], 1e-6))
    dqdt_in = (1 / h[-1]) * (dqdt[-1] - (q[-1]/h[-1]) * dhdt[-1] - c * dhdt[-1])
    dqdt_out = (1 / h[-1]) * (dqdt[-1] - (q[-1]/h[-1]) * dhdt[-1] + c * dhdt[-1])
    dqdt[-1] = dqdt_in + dqdt_out  # superpose characteristics (simplified)

# --- Time derivative function ---
def shallow_water_rhs(t, u):
    h, q = u[:nx], u[nx:]
    ζ = h + zb
    h_p, h_m = np.roll(h, -1), np.roll(h, 1)
    q_p, q_m = np.roll(q, -1), np.roll(q, 1)
    ζ_p, ζ_m = np.roll(ζ, -1), np.roll(ζ, 1)

    dhdt = -(q_p - q_m) / (2 * dx)
    dqdx = ((q_p**2 / (h_p + 1e-6)) - (q_m**2 / (h_m + 1e-6))) / (2 * dx)
    dzetadx = (ζ_p - ζ_m) / (2 * dx)
    dqdt = -dqdx - g * h * dzetadx - cf * q * np.abs(q) / (h**2 + 1e-6)

    apply_gabc(h, q, dhdt, dqdt)
    return np.concatenate([dhdt, dqdt])

# --- Solve the PDE ---
u0 = initial_conditions()
t_eval = np.linspace(t_start, t_stop, 500)
# sol = solve_ivp(shallow_water_rhs, (t_start, t_stop), u0, method='RK45',
#                 t_eval=t_eval, rtol=1e-6, atol=1e-6)
sol = solve_ivp(shallow_water_rhs, (t_start, t_stop), u0,
                method='DOP853', t_eval=t_eval,
                rtol=1e-8, atol=1e-8)

# # --- Create enhanced animation ---
# fig, ax = plt.subplots(figsize=(12, 6))
# line_h, = ax.plot([], [], label='Free surface', color='blue', lw=2)
# line_bed, = ax.plot([], [], label='Bed elevation', color='black', lw=1)
# fill = None
# ax.set_xlim(x_start, x_end)
# ax.set_ylim(np.min(zb)-0.1, np.max(sol.y[:nx]) + 0.2)
# ax.set_xlabel("x [m]")
# ax.set_ylabel("Elevation [m]")
# ax.set_title("1D Shallow Water Simulation with GABC")
# ax.grid(True)
# ax.legend(loc='upper right')

# def init():
#     global fill
#     line_h.set_data([], [])
#     line_bed.set_data(x, zb)
#     fill = ax.fill_between(x, zb, zb, color='lightblue', alpha=0.5)
#     return line_h, line_bed, fill

# def update(frame):
#     global fill
#     for coll in ax.collections:
#         coll.remove()
#     h = sol.y[:nx, frame]
#     surface = h + zb
#     line_h.set_data(x, surface)
#     fill = ax.fill_between(x, zb, surface, color='lightblue', alpha=0.5)
#     ax.set_title(f"t = {sol.t[frame]:.2f} s")
#     return line_h, line_bed, fill

# ani = FuncAnimation(fig, update, frames=len(sol.t), init_func=init, blit=False)
# ani.save("shallow_water_gabc_nice_rk8.gif", writer=PillowWriter(fps=30))
# plt.close()

print("✅ Enhanced GIF saved as 'shallow_water_gabc_nice.gif'")

def compute_energy(h, q):
    """Compute total mechanical energy: potential + kinetic"""
    potential = g * (h + zb) * h * dx  # potential energy
    kinetic = 0.5 * (q**2 / (h + 1e-6)) * dx  # kinetic energy
    return np.sum(potential + kinetic)

methods = ['RK45', 'DOP853', 'Radau']
tolerances = [1e-3, 1e-5, 1e-7, 1e-9]
final_energies = {}
initial_energy = compute_energy(*np.split(u0, 2))

for method in methods:
    for tol in tolerances:
        sol_test = solve_ivp(shallow_water_rhs, (t_start, t_stop), u0, method=method,
                             t_eval=t_eval, rtol=tol, atol=tol)
        h_final = sol_test.y[:nx, -1]
        q_final = sol_test.y[nx:, -1]
        energy = compute_energy(h_final, q_final)
        key = f"{method}_tol{tol:.0e}"
        final_energies[key] = abs((energy - initial_energy) / initial_energy)

# Plot energy error vs tolerance
plt.figure(figsize=(10, 6))
for method in methods:
    errs = [final_energies[f"{method}_tol{tol:.0e}"] for tol in tolerances]
    plt.loglog(tolerances, errs, marker='o', label=method)

plt.xlabel("Tolerance (rtol=atol)")
plt.ylabel("Relative Energy Error at Final Time")
plt.title("Energy Error Scaling with Tolerance")
plt.grid(True, which='both', ls='--')
plt.legend()
plt.tight_layout()
plt.savefig("energy_error_scaling.png")
plt.close()
print("✅ Energy error scaling plot saved as 'energy_error_scaling.png'")

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

# --- Parameters ---
g = 9.81
D = 10.0
x_start, x_end = 0.0, 5.0
nx = 200
dx = (x_end - x_start) / (nx - 1)
x = np.linspace(x_start, x_end, nx)
zb = -D + 0.4 * np.sin(2 * np.pi * x / x_end * ((nx - 1)/nx) * 5)
cf = 0.0

t_start, t_stop = 0.0, 1.0
dt = 0.002
nt = int((t_stop - t_start) / dt)
t_vals = np.linspace(t_start, t_stop, nt)

# --- Initial condition ---
def initial_conditions():
    h0 = 1 * np.exp(-100 * ((x / x_end - 0.5) * x_end)**2) - zb
    q0 = np.zeros_like(h0)
    return np.concatenate([h0, q0])

# --- GABC treatment ---
def apply_gabc(h, q, dhdt, dqdt):
    c = np.sqrt(g * max(h[0], 1e-6))
    dqdt[0] = ((1 / h[0]) * (dqdt[0] - (q[0]/h[0]) * dhdt[0] + c * dhdt[0]) +
               (1 / h[0]) * (dqdt[0] - (q[0]/h[0]) * dhdt[0] - c * dhdt[0]))

    c = np.sqrt(g * max(h[-1], 1e-6))
    dqdt[-1] = ((1 / h[-1]) * (dqdt[-1] - (q[-1]/h[-1]) * dhdt[-1] - c * dhdt[-1]) +
                (1 / h[-1]) * (dqdt[-1] - (q[-1]/h[-1]) * dhdt[-1] + c * dhdt[-1]))

# --- RHS of the PDE ---
def rhs(u):
    h, q = u[:nx], u[nx:]
    ζ = h + zb
    h_p, h_m = np.roll(h, -1), np.roll(h, 1)
    q_p, q_m = np.roll(q, -1), np.roll(q, 1)
    ζ_p, ζ_m = np.roll(ζ, -1), np.roll(ζ, 1)

    dhdt = -(q_p - q_m) / (2 * dx)
    dqdx = ((q_p**2 / (h_p + 1e-6)) - (q_m**2 / (h_m + 1e-6))) / (2 * dx)
    dzetadx = (ζ_p - ζ_m) / (2 * dx)
    dqdt = -dqdx - g * h * dzetadx - cf * q * np.abs(q) / (h**2 + 1e-6)

    apply_gabc(h, q, dhdt, dqdt)
    return np.concatenate([dhdt, dqdt])

# --- Solvers ---
def solve_euler_forward(u0):
    u = u0.copy()
    result = []
    for _ in range(nt):
        result.append(u.copy())
        u += dt * rhs(u)
    return np.array(result)

def solve_euler_backward(u0, iters=2):
    u = u0.copy()
    result = []
    for _ in range(nt):
        result.append(u.copy())
        u_guess = u.copy()
        for _ in range(iters):
            u_guess = u + dt * rhs(u_guess)
        u = u_guess
    return np.array(result)

def solve_midpoint(u0):
    u = u0.copy()
    result = []
    for _ in range(nt):
        result.append(u.copy())
        k1 = rhs(u)
        k2 = rhs(u + 0.5 * dt * k1)
        u += dt * k2
    return np.array(result)

# --- Run simulations ---
u0 = initial_conditions()
sol_fwd = solve_euler_forward(u0)
sol_bwd = solve_euler_backward(u0)
sol_mid = solve_midpoint(u0)

# --- Set up the animation ---
fig, axes = plt.subplots(1, 3, figsize=(15, 5), sharey=True)
titles = ['Euler Forward', 'Euler Backward', 'Midpoint Method']
lines = []
fills = []

ymin = np.min(zb) - 0.1
ymax = 1.2  # Reasonable upper bound for water surface

for ax, title in zip(axes, titles):
    ax.set_xlim(x_start, x_end)
    ax.set_ylim(ymin, ymax)
    ax.set_title(title)
    ax.set_xlabel("x [m]")
    ax.grid(True)
    line, = ax.plot([], [], lw=2)
    lines.append(line)
    fills.append(ax.fill_between(x, zb, zb, color='lightblue', alpha=0.5))
axes[0].set_ylabel("Elevation [m]")

def init():
    for line in lines:
        line.set_data([], [])
    return lines + fills

def update(frame):
    for ax in axes:
        for coll in ax.collections[1:]:
            coll.remove()

    h_fwd = sol_fwd[frame, :nx]
    h_bwd = sol_bwd[frame, :nx]
    h_mid = sol_mid[frame, :nx]
    hs = [h_fwd, h_bwd, h_mid]

    for ax, line, h in zip(axes, lines, hs):
        surface = h + zb
        line.set_data(x, surface)
        ax.fill_between(x, zb, surface, color='lightblue', alpha=0.5)

    fig.suptitle(f"Time = {frame * dt:.3f} s")
    return lines + fills

ani = FuncAnimation(fig, update, frames=nt, init_func=init, blit=False)
ani.save("solver_comparison.gif", writer=PillowWriter(fps=30))
plt.close()

print("✅ Animation saved as 'solver_comparison.gif'")